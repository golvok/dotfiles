# If not running interactively, don't do anything
[[ $- != *i* ]] && return

PATH="$PATH:/home/matt/bin"
PATH="$PATH:/opt/altera/quartus/bin"
PATH="$PATH:/opt/altera/modelsim_ae/bin/"
# PATH="$PATH:/home/matt/pebble-dev/PebbleSDK-3.7/bin"

export SCIPY_PIL_IMAGE_VIEWER="xdg-open"

alias nvidia-settings='primusrun nvidia-settings -c :8'
alias afpNITROGENmatthome='afp_client mount -u matt -p - "NITROGEN.local:matt" ~/afp_NITROGENmatthome'
alias minecraft='primusrun java -jar ~/Software/minecraftLauncher.jar'
alias gcc-m='gcc -std=c99 -lm'
alias gcc-md='gcc-m -Wall -pedantic -Wextra'
alias gitst='git status'

alias wine32='WINEPREFIX=~/.wine32 WINEARCH=wine32'
alias cdcs="cd '/home/matt/Documents/school/UofT MASc/year 1'"
alias clip-copy='xclip -selection c'
alias clip-paste='xclip -selection o'

function remake { (
	make clean "$@" && make "$@"
) }

function virtualbox() {
	sudo modprobe vboxdrv;
	sudo modprobe vboxnetadp;
	sudo modprobe vboxnetflt;
	/usr/bin/virtualbox;
}

function man() {
	env LESS_TERMCAP_mb=$'\E[01;31m' \
	LESS_TERMCAP_md=$'\E[01;38;5;74m' \
	LESS_TERMCAP_me=$'\E[0m' \
	LESS_TERMCAP_se=$'\E[0m' \
	LESS_TERMCAP_so=$'\E[38;5;246m' \
	LESS_TERMCAP_ue=$'\E[0m' \
	LESS_TERMCAP_us=$'\E[04;38;5;146m' \
	man "$@"
}

function funchelp() { grep "function" "$HOME/.bashrc"; }

function edit() {
	if [[ $1 == "brc" ]]; then
		echo "not what you meant"
		return;
	fi
	for f in "$@"; do
		touch "$f";
	done
	subl3 -n "$@";
}

function editbrc() { edit ~/.bourne-shell-compatible-rc "$@"; }

function gerp() { grep "$@"; }
alias grep="grep --color=always"
function trim_whitespace() {
	echo "$1" | awk '{gsub(/(^ +)|( +$)/,"")} {print $0}'
}

function line() { (
	if [[ $2 == "" ]]; then
		set -- "${@:1:1}" "." "${@:3}"
	fi
	exec 5>&1;
	FILES=$(grep --binary-files=without-match --color=always -rni "$@" | awk 'BEGIN{i=0}{i++; print i ": " $0}' | tee >(cat - >&5) | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" | cut -d ":" -f2-3)
	if [[ $FILES == "" ]]; then
		echo "no matches!";
		return;
	fi
	echo -n "choose line (n,e,#): "
	read LINE_CHOICE
	if [[ $LINE_CHOICE == "n" ]]; then
		ARGS="-n"
		echo -en "choose line (in new editor) (e,#): "
		read LINE_CHOICE
	fi
	if [[ $LINE_CHOICE == "e" ]]; then
		P4_EDIT_IT="yes"
		echo -en "will p4 edit. choose line (n,#): "
		read LINE_CHOICE
	fi
	if [[ $LINE_CHOICE == "n" ]]; then
		ARGS="-n"
		echo -en "choose line (in new editor) (#): "
		read LINE_CHOICE
	fi

	FILE_AND_LINE_TO_EDIT="$(trim_whitespace "$(echo "$FILES" | sed -n "${LINE_CHOICE}p" )" )"
	FILE_TO_EDIT="${FILE_AND_LINE_TO_EDIT%:*}"

	if [[ $P4_EDIT_IT == "yes" ]]; then
		p4 edit "$FILE_TO_EDIT"
	fi

	$EDITOR $ARGS "$FILE_AND_LINE_TO_EDIT"
); }

function pn() { ping-noise "$@"; }
function ping-noise() {
	TIMES="1"
	DELAY="no"

	if [[ $1 == "-d" ]]; then
		DELAY="yes"
		if [[ $2 != "" ]]; then
			TIMES="$2"
		fi
	elif [[ $1 != "" ]]; then
		TIMES="$1"
	fi

	for i in $(seq 1 "$TIMES"); do
		if [[ $DELAY == "yes" ]]; then
			sleep 2
		fi
		( sox -v 0.05 ~/Audio/Ding_by_Aiwha.ogg -dq & )
		DELAY="yes"
	done
}

function nn() { noise-notify "$@"; }
function noise-notify() {
	if [[ "$@" == "" ]]; then
		MESSAGE="$PWD";
	else
		MESSAGE="$@";
	fi

	ping-noise & notify-send -t 60000 "$MESSAGE";
}

function make-p() { (
	make -j9 -l9 "$@"
	MAKE_RESULT="$?"

	NOTIFY_STRING="$(basename $PWD): 'make_p $*' done"

	nn "$NOTIFY_STRING" &

	exit "$MAKE_RESULT"
) }
alias make_P=make-p;

function wait-for() {
	if [[ $1 == "-r" ]]; then
		REMOVE=true
		FILE="$2"
	else
		REMOVE=false
		FILE="$1"
	fi

	while [ ! -f "$FILE" ]; do
		sleep 2
	done

	echo "waited!"

	if [[ $REMOVE = true ]]; then
		rm "$FILE"
	fi
}

function anywait(){
	for pid in "$@"; do
		while kill -0 "$pid"; do
			sleep 0.5
		done
	done
}

function cdar() { cd *"$@"* ; }
function cdrecent() { cd $(find ./ -maxdepth 1 -type d -regex \"\\\\./[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-.*\" | sort | tail -n 1 - ) "$@"; }
function cdlast() { cd $(find ./ -maxdepth 1 -type d | tail -n 1 - ) "$@"; }
function cd..() { cd ".." "$@"; }

function decolour() { echo -ne '\e[0m' "$@"; }

function go() { for arg in "$@" ; do xdg-open "$arg" & done; }

function rmthisdir() {
	HERE="$PWD"
	rmdir -v "$HERE" && cd "$(dirname "$HERE")"
}

alias ls="ls --color=auto"
alias oeu=ls

alias les="less"
alias lesss="less"
alias less="less -SIR"

function date() {
	if [ $# -eq 0 ]; then
		date "+%F %T (%a)";
	else
		/usr/bin/env date "$@"
	fi
}

function mkdatedir() {
	mkdir "$(date "+%F")-$1"
}

function tsv_view() {
	if ! [ $? ]; then
		return
	fi

	FILE="$(mktemp)"

	# all short lines go through column
	grep -v -e '[^\]\{84,\}' "$1" | column -s "	" -t >> "$FILE"

	# the rest get pasted at the end
	grep -e '[^\]\{84,\}' "$1" >> "$FILE"

	# open the resutls in less
	less -#2 -SI "$FILE"

	# remove temporary
	rm -f "$FILE"
}

function untar() { tar -xf "$1"; }
function tarxz() { tar -cJf "$1.tar.xz" "$1"; }
function untarxz() { tar -xJf "$1"; }

# print process tree, up to init
function procsup() {
	leaf=$$;
	ps -eo pid,ppid,command | awk -v leaf="$leaf" '
		{parent[$1]=$2;command[$1]=$3;}
		function print_ancestry(pid)
		{
			print pid " : " command[pid]
			if(pid!=1) print_ancestry(parent[pid])
		};
		END{
			print_ancestry(leaf)
		}
	'
}

function do_in_parallel() {
	for d in $1; do
		( cd "$d" && $2 ) &
	done
	wait
	( ping-noise & )
}

function stashmake() {
	git stash && make "$@" && git stash pop
}

function ioctave() {
	octave --no-gui "$@"
}

export EDITOR=vim
export VISUAL="$EDITOR"
# PS1='[\u@\h \W]\$ '

export ANDROID_HOME=/opt/android-sdk

function update-mirrrorlist() {
	reflector --verbose -l 200 -a $(: seven days; echo 168) -p https -p http --sort rate --country "Canada" --country "United States" --save /etc/pacman.d/mirrorlist
}

function lines-to-math() {
	awk 'BEGIN{printf " ( ";} {printf $1; printf" '"$1"' "} END{printf '"$2"'; printf " ) "}'
}

function gprof-loop() {
	if [ $# -lt 2 ]; then
		echo "usage: gprof-loop <number of runs> <commandline...>"
		return 1
	fi

	for i in $(seq 1 $1); do

		# Run profiled program
		commandline=( "${@:2}" )
		"${commandline[@]}"

		# Accumulate gprof statistic
		if [ -e gmon.sum ]; then
			gprof -s $2 gmon.out gmon.sum && rm gprof.out
		else
			mv gmon.out gmon.sum
		fi
	done

	# make final output
	gprof block_hasher gmon.sum > gmon.out && rm gmon.sum
}

function time-loop() {
	if [ $# -lt 2 ]; then
		echo "usage: time-loop <number of runs> <commandline...>"
		return 1
	fi

	for i in $(seq 1 $1); do

		# Run profiled program
		commandline=( "${@:2}" )
		time "${commandline[@]}" > "stdout-$i.txt"

	done
}

function my-torch-activate() {
	source "/home/matt/Software/torch-distro/install/bin/torch-activate"
}

function findable-spam() {
	for i in $(seq 1 7); do echo "= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="; done;
}
